## 里氏替换原则
### 一、定义    
1. 如果对于每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的程序P在所有对象o1都替换为o2时程序P的行为没有发生变化，那么类型S是类型T的子类型。     
2. 所有引用基类的地方必须能透明的使用其子类对象。          
- 即里氏替换原则要求子类在继承父类时不能修改父类已实现的方法；
- 父类出现的地方子类就可以出现，即程序中的任意对象都可以被它的子类所替换并且程序功能不会发生变化。

### 二、设计原则      
1. 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生畸变，则建议断开父子继承关系，采用依赖、聚合、组合代替继承。
    - 假设存在一个枪支的抽象类。定义了一个射击的抽象方法,有步枪、机枪、手枪等实现类
    - 此时，我们再添加一个玩具枪，由于玩具枪是不具备射击功能的，所以它就不能继承抽象枪类
2. 覆盖或实现父类的方法时输入参数可以被放大。
    - 假设在父类存在一个方法`fun1`接受的参数为`HashMap`类型，那么，当子类覆盖这个方法时，可以接收一个Map类型的参数
    - 因为`HashMap`为`Map`的子类型，那么只要是父类出现的地方都可以使用子类进行替换，但是子类出现的地方父类不一定适用。
3. 覆盖或实现父类方法时输出结果可以被缩小
    - 假设父类存在一个方法`public Map fun1(){}`返回值要求是Map类型
    - 此时如果他的子类重写父类的该方法时，可以返回一个`HashMap`。
    