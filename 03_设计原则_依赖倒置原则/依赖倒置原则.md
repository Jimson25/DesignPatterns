## 依赖倒置原则       
1. 定义
    1. 高层模块不应依赖低层模块
    2. 抽象不应该依赖细节(抽象类或接口不应该依赖实现类)
    3. 细节应该依赖抽象（实现类之间通过抽象层耦合）   
    __总结:__ 面向接口编程!!
           
2. 依赖倒置原则在`java`中的表现就是:
    1. 模块之间的抽象通过抽象发生，类与类之间不直接依赖，而是通过抽象类或者接口耦合
    2. 接口或抽象类不依赖实现类
    3. 实现类依赖接口或抽象类       
    __以上总结：__ 
    - 假设存在一个`狙击手`类,狙击手需要一把枪,那么根据第一条他就不能直接依赖一个具体的狙击枪而是依赖一个抽象的枪类
    - 将上一条中的`狙击手`提取成`士兵`这一抽象类,狙击手继承士兵类.此时士兵分为很多种,他们是不能依赖某一具体的枪的
    类型的,所以士兵应该依赖一个抽象的枪类然后让不同的子类实现各自的依赖.
    - 对于一个具体的士兵而言可以有多种不同的枪支选择,即3
    
3. 优点
    - 可以减少类之间的耦合性,提高系统稳定性  
    ```java
   //例1. 司机类
   public class Driver{
       public void drive(Benz car){
           car.run();
       }
   } 
   ```
   ```java
   //例2. 
   public abstract class ICar{
       public void run();
   }
   public class Benz extends ICar{
       public void run(){
           System.out.println("Benz is running");
       }   
   }
   public class BMW extends ICar{
       public void run(){
           System.out.println("BMW is running");
       }   
   }
   //司机类
   public class Driver{
       public void drive(Benz car){
           car.run();
       }
   }
   /**
    例一中,司机只能驾驶奔驰汽车,如果想要更换为其他车型就得修改司机类
    例二中,司机通过抽象的汽车类与汽车耦合,更换其他车型时只需要更换传入的实例对象即可
    这里还可以在四类上面抽取出一个抽象的司机类
   */
    ```
    - 降低代码并行开发引起的风险
    - 提高代码的可读性和可维护性
    
4. 最佳实践
    - 每个类都尽量接口或抽象类,或者接口和抽象类都具备
        > 如上例中的`Benz`和 `BWM`两个类都继承抽象类`ICar`,有抽象才能倒置
    - 对象的表面类型尽量是接口或者抽象类
    - 任何类都不应该从具体类派生 `Object?`
    
    